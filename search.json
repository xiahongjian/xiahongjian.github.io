[{"title":"Idea常用快捷键","url":"/2019/05/29/Idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"插件推荐推荐大家安装IDE Features Trainer这款插件，插件通过示例帮助我们记忆各种常用的快捷键，以下收录的快捷键都是插件中提及的。\n\n快捷键速查⌥⇧→: to move caret to next word and select everything between in\n⌥↑: to extend the selection to the next code block\n⌥↓: to shrink selection\n⌃/: Basic Completion\n⇧F6: to rename\n⌘⌥L: to format code\n⌘⌃G: 选择文件中的所有相同符号\nF2: to jump the next highlight error\n⌘F1: to see error description\n⌘⇧F7: to highlight all usages of the symbol at caret with the file\n⌘P: to see the method signature\n⌘↓： to look up the source\n⌘B: to jump the declaration of a class of interface\n⌘F12: to see the file sturcture\n⌘F: to call the Find action\n⏎ or ⌘G: to find next occurrences\n⌘⇧G: to find previous occurrences\n","tags":["Idea","快捷键"]},{"title":"Java线程之前数据传递的方案","url":"/2025/04/08/Java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E6%A1%88/","content":"引言在日常开发中经常遇到这样一个场景：在拦截器中对用户做统一的鉴权，鉴权通过后将当前登录用户的信息ThreadLocal使用存储在当前线程中，方便后续业务代码中使用。但有时，执行的业务比较耗时，我们会将业务执行逻辑封装到由@Async标注的异步方法中或提交到线程池中执行，这时在执行业务代码会无法获取到之前缓存的用户信息，因为线程已经发生了切换。那么，我们改怎样将任务提交任务线程缓存的数据传递给执行线程呢？\n\nThreadLcoal的原理首先，我们简单看一下ThreadLocal的基本原理。使用ThreadLocal#set方法存储的数据会存储在当前线程的threadLcoals成员变量中，threadLocals的类型是ThreadLocal.ThreadLocalMap，可以简单的理解成一个Map。当调用ThreadLocal#get时，会从当前线程的threadLocals成员变量中取出存储的值。\n使用InheritableThreadLocal传递数据InheritableThreadLocal可以将数据由父线程传递给子线程。与ThreadLcoal类似，InheritableThreadLocal也是将数据存储在当前线程的一个成员变量里（inheritableThradLocals）。\n/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;/* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n那么父线程是怎么将数据传递给子线程的呢？查看Thread类的构造方法，可以看到初始化inheritableThreadLocals时使用了ThreadLcoal.createInheriableMap，并传递了父线程的inheriableThreadLocal作为参数。\nThread(String name, int characteristics, boolean bound) &#123;    // ...    // 省略无关代码    // thread locals    if ((characteristics &amp; NO_INHERIT_THREAD_LOCALS) == 0) &#123;        Thread parent = currentThread();        ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;        // 在这里做了初始化        if (parentMap != null &amp;&amp; parentMap.size() &gt; 0) &#123;            this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);        &#125;        this.contextClassLoader = contextClassLoader(parent);    &#125; else &#123;        // default CCL to the system class loader when not inheriting        this.contextClassLoader = ClassLoader.getSystemClassLoader();    &#125;        // 省略无关代码    // ...&#125;\n运行以下代码：\npublic class Test &#123;    public static void main(String[] args) &#123;        InheritableThreadLocal&lt;String&gt; currentUserHolder = new InheritableThreadLocal&lt;&gt;();        currentUserHolder.set(&quot;tom&quot;);        System.out.printf(&quot;Thread: %s, current user: %s%n&quot;, Thread.currentThread().getName(), currentUserHolder.get());        Thread child = new Thread(() -&gt; &#123;            System.out.printf(&quot;Thread: %s, current user: %s%n&quot;, Thread.currentThread().getName(), currentUserHolder.get());        &#125;);        child.start();    &#125;&#125;\n得到结果：\nThread: main, current user: tomThread: Thread-0, current user: tom\n数据成功地从父线程传递到了子线程。但是inheriableThreadLocals的初始化在线程创建的时候，线程创建后，对InheritableThreadLocal实例后续的操作子线程将无法感知。执行以下代码：\npublic class Test &#123;    public static void main(String[] args) &#123;        InheritableThreadLocal&lt;String&gt; currentUserHolder = new InheritableThreadLocal&lt;&gt;();        currentUserHolder.set(&quot;tom&quot;);        System.out.printf(&quot;Thread: %s, current user: %s%n&quot;, Thread.currentThread().getName(), currentUserHolder.get());        Thread child = new Thread(() -&gt; &#123;            System.out.printf(&quot;Thread: %s, current user: %s%n&quot;, Thread.currentThread().getName(), currentUserHolder.get());        &#125;);        // 调整InheritableThreadLocal中存储的值        currentUserHolder.set(&quot;jerry&quot;);        System.out.printf(&quot;Thread: %s, current user: %s%n&quot;, Thread.currentThread().getName(), currentUserHolder.get());        child.start();    &#125;&#125;\n会得到以下结果：\nThread: main, current user: tomThread: main, current user: jerryThread: Thread-0, current user: tom\n因此InheritableThreadLocal并不能胜任一般的业务场景，因为一般都不会手动新建线程，而是使用线程池。\n手动传递ThreadLocal中的值既然InheriableThreadLocal自动传递数据有局限性，那么是否可以手动传递呢？答案当然是：可以！\n线程池的使用public class TaskWrapperTest &#123;    public static class UserCtxHolder &#123;        private static final ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();        public static String get() &#123;            return threadLocal.get();        &#125;        public static void set(String val) &#123;            threadLocal.set(val);        &#125;        public static void clean() &#123;            threadLocal.remove();        &#125;    &#125;    public static class UserCtxAwareRunnable implements Runnable &#123;        private final String currentUser;        private final Runnable task;        public UserCtxAwareRunnable(Runnable task) &#123;            this.currentUser = UserCtxHolder.get();            this.task = task;        &#125;        @Override        public void run() &#123;            try &#123;                UserCtxHolder.set(currentUser);                task.run();            &#125; finally &#123;                UserCtxHolder.clean();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        UserCtxHolder.set(&quot;tom&quot;);        System.out.println(&quot;Thread: %s, current user: %s&quot;.formatted(Thread.currentThread().getName(), UserCtxHolder.get()));        try (ExecutorService executor = Executors.newSingleThreadExecutor()) &#123;            executor.execute(new UserCtxAwareRunnable(() -&gt; System.out.println(&quot;Thread: %s, current user: %s&quot;.formatted(Thread.currentThread().getName(), UserCtxHolder.get()))));        &#125;    &#125;&#125;\n运行结果：\nThread: main, current user: tomThread: pool-1-thread-1, current user: tom\n每次执行任务的时候都需要传递自定义的Runnalbe的包装类UserCtxAwareRunnalbe的实例，这样不可避免存在无用，未使用包装类，直接传入Runnable实例，导致数据未传递。为避免这种情况，可以自定义一个线程池，传入Runnable实例时，自动使用UserCtxAwareRunnable包装。\npublic class CommonBizThreadPool implements Executor &#123;    public static final CommonBizThreadPool INSTANCE = new CommonBizThreadPool();    private final Executor executor;    private CommonBizThreadPool() &#123;        // 示例代码，勿用于生产环境，实际按需创建线程池        executor = Executors.newSingleThreadExecutor();    &#125;    @Override    public void execute(Runnable command) &#123;        // 在这里包装Runnable实例        executor.execute(new UserCtxAwareRunnable(command));    &#125;&#125;\nSpring异步任务接下来要处理另一个问题，对于@Async注解标记的异步方法，这些方法默认使用spring定义的ThreadPoolTaskExecutor线程池执行，我们也要对这个线程池执行的任务进行上文类似装饰（手动设置ThreadLocal）。ThreadPoolTaskExecutor提供了setTaskDecorator方法，使得我们可以“装饰”一个任务。定义一个任务装饰器\npublic class UserCtxAwareTaskDecorator implements TaskDecorator &#123;    @Override    public Runnable decorate() &#123;        String currentUser = UserCtxHolder.get();        return () -&gt; &#123;            try &#123;                UserCtxHolder.set(currentUser);                runnable.run();            &#125; finally &#123;                UserCtxHolder.clean();            &#125;        &#125;;    &#125;&#125;\n定义ThreadPoolTaskExecutorbean\n@Configurationpublic class BeanConfiguration &#123;    @Bean    public ThreadPoolTaskExecutor threadPoolTaskExecutor() &#123;        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();        // 线程池参数根据实际需求修改        executor.setCorePoolSize(5);        executor.setMaxPoolSize(10);        executor.setQueueCapacity(100);        executor.setThreadNamePrefix(&quot;custom-&quot;);        // 设置任务装饰器        executor.setTaskDecorator(new UserCtxAwareTaskDecorator());        executor.initialize();        return executor;    &#125;&#125;\n延申如果使用到了多个ThreadLocal，那么就需要在线程池任务包装类UserCtxAwareRunnable和UserCtxAwareTaskDecorator中处理这些ThreadLocal，这样就有些繁琐了。其实我们可以借助阿里的transmittable-thread-local，轻松的实现数据在父子线程中传递。\n\n引入依赖\n &lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;/groupId&gt;&lt;artifactId&gt;transmittable-thread-local&lt;/artifactId&gt;&lt;version&gt;2.14.5&lt;/version&gt;&lt;/dependency&gt;\n\n替换原来使用的ThreadLocal为TransmittableThreadLocal\n public class UserCtxHolder &#123;    private static final TransmitableThreadLocal&lt;String&gt; threadLocal = new TTransmitableThreadLocal&lt;&gt;();    public static String get() &#123;        return threadLocal.get();    &#125;    public static void set(String val) &#123;        threadLocal.set(val);    &#125;    public static void clean() &#123;        threadLocal.remove();    &#125;&#125;\n\n使用TtlExecutors.getTtlExecutor装饰原线程池\n public class CommonBizThreadPool2 &#123;    // 使用TtlExecutors.getTtlExecutor装饰原线程池    public static final Executor INSTANCE = TtlExecutors.getTtlExecutor(Executors.newSingleThreadExecutor());    public static Executor getInstance() &#123;        return INSTANCE;    &#125;&#125;\n\n创建一个实现了AsyncConfigurater接口的bean（处理@Async异步调用时的数据传递）\n @Componentpublic class CustomAsyncConfig implements AsyncConfigurer &#123;    @Override    public Executor getAsyncExecutor() &#123;        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();        // 线程池参数根据实际情况设置        executor.setCorePoolSize(5);        executor.setMaxPoolSize(10);        executor.setQueueCapacity(100);        executor.setThreadNamePrefix(&quot;CustomAsyncConfig-&quot;);        executor.initialize();        // 包装线程池        return TtlExecutors.getTtlExecutor(executor);    &#125;&#125;\n\n\n","categories":["Java"],"tags":["Java","Spring"]},{"title":"Let's Encrypt HTTPS证书申请、安装及自动续期","url":"/2019/03/28/Let-s-Encrypt-HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E3%80%81%E5%AE%89%E8%A3%85%E5%8F%8A%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F/","content":"概述由于新版本的Chrome对于非HTTPS网站都会提示不安全，十分影响使用体验，所以打算把博客站点升级到HTTPS。\n运行环境此博客系统的运行环境是阿里云Ubuntu14.04(不记得当初买ECS的时候为什么会选这个版本，可能是忘记选了吧😂)，Nginx, Spring Boot。\n\nNginx https模块支持当初安装Nginx时没有配置支持https，所以需要重新编译一个支持httpps的Nginx。\n首先确定自己的Nginx的版本及编译参数（如果支持https即可跳过接下来的步骤）。执行nginx -V，确定Nginx版本。\n下载对应版本的Nginx源码,解压后进入目录, 执行以下命令\n./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-file-aio --with-http_realip_modulemake\n注意 --prefix需要输入自己的Nginx安装目录，否则运行Nginx时会出现无法打开log文件、配置文件等问题。编译完毕后objs目录下就有个nginx文件，此文件就是我们需要的。\n备份原来的Nginx程序。\ncp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak\nkill Nginx进程，然后复制新编译的Nginx。\ncp ./objs/nginx /usr/local/nginx/sbin/nginx\n启动Nginx，完工。\n安装Certbot-auto及证书生成下载Certbot-auto, chmod +x certbot-auto添加运行执行权限。\n这里我需要申请的是通配符证书，所以申请过程中需要为DNS增加一条TXT记录，为了方便以后自动续期(renew)，需要用到另外一个项目certbot-letencrypt-wildcardcertificates-alydns-au，这个项目功能自动调用API为DNS添加TXT记录。\n下载certbot-letencrypt-wildcardcertificates-alydns-au后需要在脚本中配置上自己的API Key。执行下面的命令测试(具体脚本的参数，参考项目的README)\n./certbot-auto certonly  -d *.example.com --manual --preferred-challenges dns --dry-run  --manual-auth-hook &quot;/脚本目录/au.sh php aly add&quot; --manual-cleanup-hook &quot;/脚本目录/au.sh php aly clean&quot; \n没有问题后执行以下命令，正式生成证书\n./certbot-auto certonly  -d *.example.com --manual --preferred-challenges dns --dry-run  --manual-auth-hook &quot;/脚本目录/au.sh php aly add&quot; --manual-cleanup-hook &quot;/脚本目录/au.sh php aly clean&quot; \n查看生成的证书\n./certbot-auto certificates\n证书续期\n./certbot-auto renew  --manual --preferred-challenges dns --manual-auth-hook &quot;/脚本目录/au.sh php aly add&quot; --manual-cleanup-hook &quot;/脚本目录/au.sh php aly clean&quot;  \n加入crontab编辑文件 /etc/crontab :\n#证书有效期&lt;30天才会renew，所以crontab可以配置为1天或1周，成功续期后Nginx reload1 1 */1 * * root certbot-auto renew --manual --preferred-challenges dns --deploy-hook  &quot;nginx -s reload&quot;--manual-auth-hook &quot;/脚本目录/au.sh php aly add&quot; --manual-cleanup-hook &quot;/脚本目录/au.sh php aly clean&quot; \n配置Nginx编辑配置文件/usr/local/nginx/conf/nginx.conf\n## 将http请求转发到httpsserver &#123;     listen      80;     server_name     www.example.com example.com test.example.com;     rewrite ^(.*)$  https://$host$1 permanent;&#125;server &#123;    server_name  www.example.com example.com test.example.com;    listen 443;    ssl on;    ssl_certificate /etc/letsencrypt/live/example.comfullchain.pem;    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;    ssl_trusted_certificate  /etc/letsencrypt/live/example.com/chain.pem;     location / &#123;        proxy_pass http://127.0.0.1:8080;               ## 做反向代理需要设置请求header，防止丢失访问者的原IP        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        ## websocket配置        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;                       proxy_set_header Connection &quot;upgrade&quot;;    &#125;&#125;\nreload\nnginx -s reload\n🎉大功告成\n","categories":["HTTPS"],"tags":["HTTPS","Nginx","Certbot-auto"]},{"title":"第一篇博文--记录搭建过程遇到的问题","url":"/2019/03/23/first/","content":"\n此博文是从之前自己搭建的博客系统中迁移过来的。\n\n起源在2017年12月底，当时兴起了一个搭建自己的博客想法，然后买了服务器，开始着手搭建。但是后面由于种种原因搁置了（其实就是自己的拖延症😂）。之后断断续续写了一点代码，直到今年年后，才真正开始。\n项目相关首先此博客系统是根据Tale修改而来，主要是将后台实现替换成了Spring Boot+MyBatis+FreeMarker，在此也要感谢Tale的作者@biezhi写出了这么棒的项目。\n\n搭建过程中遇到的问题整个过程中遇到了大大小小不少问题，在此总结分析给大家。主要有以下问题：\n\nLinux下MySQL默认数据库和表名区分大小写。\nSpring Boot中实现上传图片，并可以通过链接直接访问。\nMyBatis 不同数据库SQL的兼容性处理\n\n具体解决Linux下MySQL默认数据库和表名区分大小写通过修改/etc/mysql/my.cnf配置文件，在[mysqld]下增加lower_case_table_names = 1，重启服务即可。\n过程中需要注意的问题是，如果已经存在包含大写字母的数据库或表，在设置不区分大小写之后，操作它们时候会报不存在的错误。所以应该先将数据库或表名修改成小写之后再做配置。\nSpring Boot中实现上传图片，并可以通过链接直接访问Spring Boot默认classpath下的static和public目录文件会作为静态资源处理，通过连接直接访问。所以一般直接将图片文件写入这两个目录下即可，但是如果将项目以jar包的形式部署，写文件时将会出现问题。\n所以解决方案是将，图片文件写到磁盘固定路径，并将该路径也配置成静态资源目录即可。以下是application.yml中的相关配置。\nspring:  mvc:    static-locations: classpath:/static,file:$&#123;web.upload-path&#125;    static-path-pattern: /static/**web:  upload-path: ./upload/\n将当前目录下的upload目录配置为静态资源目录，需要注意的是file:协议前缀不能缺少，以及./upload/需要以/结尾，否则目录下文件将无法正常访问。\nMyBatis 不同数据库SQL的兼容性处理\n配置DatabaseIdPrivider\n\n@Configurationpublic class MyBatisConfig &#123;    @Bean    public DatabaseIdProvider databaseIdProvider() &#123;        DatabaseIdProvider provider = new VendorDatabaseIdProvider();        Properties prop = new Properties();        prop.setProperty(&quot;MySQL&quot;, &quot;mysql&quot;);        prop.setProperty(&quot;SQLite3&quot;, &quot;sqlite3&quot;);        provider.setProperties(prop);        return provider;    &#125;&#125;\n\n在mapper.xml配置文件中编写对于不同数据库的SQL\n\n&lt;select id=&quot;selectRandom&quot; resultMap=&quot;BaseResultMap&quot; databaseId=&quot;mysql&quot;&gt;    select    &lt;include refid=&quot;allColumns&quot;/&gt;    from `content`    order by rand();  &lt;/select&gt;  &lt;select id=&quot;selectRandom&quot; resultMap=&quot;BaseResultMap&quot; databaseId=&quot;sqlite3&quot;&gt;    select    &lt;include refid=&quot;allColumns&quot;/&gt;    from `content`    order by random();  &lt;/select&gt;\n这样MyBatis就能根据不同数据库执行相应的SQL。\n","categories":["Java"],"tags":["MyBatis","Spring Boot","MySQL"]},{"title":"Spring Boot项目打包成jar部署读取Resources下的文件","url":"/2019/07/09/Spring-Boot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90jar%E9%83%A8%E7%BD%B2%E8%AF%BB%E5%8F%96Resources%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/","content":"起源Spring Boot项目打包成jar部署时，发现平时使用读取Resources目录的文件报错了，无法正确读取到文件。\n\n原因分析项目结构\n\nsrc\n  |--main\n      |--java\n      |    |--com\n      |        |--example\n      |              |-- ...  \n      |--resouces\n          |--data\n              |--data.json\n现在需要做的事读取data.json中的内容，下面是我实现的代码\nclass InitData &#123;  return Files.readAllBytes(Paths.get(ResourceUtils.getFile(&quot;classpath:data/data.json&quot;).getAbsolutePath()));&#125;\n由于项目是打包成jar部署的，所以getAbsolutePath()返回的是jar:开头的路径，即使用的的jar协议。而查看Path#get方法源码，使用的FileSystem只支持file协议，因此是无法正确获取到文件并读取数据。同样获取到File对象，创建FileInputStream读取文件也是不行的，因为FileInputStream也不支持jar协议。\n解决public class InitData &#123; public static byte[] getData() throws IOException &#123;  InputStream in = ResourceUtils.getURL(&quot;classpath:data/data.json&quot;).openStream();//  InputStream in = new DefaultResourceLoader().getResource(&quot;classpath:data/data.json&quot;).getInputStream();//  InputStream in = InitData.class.getResourceAsStream(&quot;data/data.json&quot;);//  InputStream in = InitData.class.getResource(&quot;data/data.json&quot;).openStream();  // 使用 InputStream读取文件内容  // ... &#125;&#125;\n上面几种实现方式大同小异，都是获取到InputStream，然后是用InputStream读取文件内容。\n总结IO操作时需要注意操作资源的协议，某些类库是只支持file协议的，用它们操作其他协议资源则会产生异常。\n","categories":["Java"],"tags":["Spring Boot"]},{"title":"《Head First设计模式》读书笔记--观察者模式","url":"/2021/04/13/hand-first-reading-notes-obsrver-pattern/","content":"什么是观察者模式\n观察者模式在对象之间定义一对多的依赖，当一个对象改变状态，依赖它的对象都会受到通知。\n\n观察者模式有两个角色：“主题”和“观察者”。观察者只需要在主题处注册，当主题状态发生变化的时候，就会主动通知观察者。这种实现方式，既使得观察者能及时获取到主题的变化，也简化了观察者的实现逻辑（不需要去不停地轮询，判断主题状态是否发生变化），同时减轻了主题的压力，因为观察者的轮询会造成性能损耗。\n \n如何实现？首先我们看一下示例的类图。\n\n此示例中，气象数据监测器(WeatherData)是主题，一个统计布告板(StatisticsDisplay)是观察者，当统计布告板注册到气象数据检测器上时，WeatherData内部就会保留一个StatisticsDisplay的引用，当数据发生变化的时候，就会主动调用update方法通知StatisticsDisplay。\n实际应用前端对DOM元素事件的监听，GUI程序中的事件监听。\n我的理解观察者模式中的观察者其实并没有真正的“观察”动作，只是告诉了主题：当你的状态发生了变化的时候通知我。所有在很多应用到观察者模式的地方，都把观察者叫做“监听器”（listener）。\n","categories":["读书笔记"],"tags":["设计模式"]},{"title":"《Head First设计模式》读书笔记--策略模式","url":"/2021/04/07/hand-first-reading-notes-strategy-pattern/","content":"背景介绍现在有一款鸭子模拟游戏：SimUDuck。游戏中会出现各种鸭子，一边游泳一边呱呱叫。\n设计很自然的可以想到，先设计一个Duck父类，并且包含两个实现好了的方法swim和quck。并且对于不同鸭子，有着不同的外观，所以需要一个display方法来描述鸭子的外观。于是乎，得到了下面这么一个抽象类Duck以及一些它的子类：\n \n业务需求变化某天客户提出来一个新的需求：我们的鸭子需要会飞，以此来制造差异化，区别于其他竞争者。\n很容易想到，只需要在父类Duck上加上fly方法，这样所有的子类都具备了飞行的能力。\n\n但是这样出现了我们不想要出现的情况——一只橡皮鸭也会飞了！\n\n显然橡皮鸭会飞是不符合预期了，一个补救措施就是：类似橡皮鸭的quck方法，覆盖fly方法，并且什么也不错。\n\n如果后续加入诱饵鸭(DecoyDuck)，诱饵鸭是木头鸭，既不会飞也不会叫。所以：\n\n现在看来，继承有时并不是一个完美的解决方案。对于父类的修改将会影响到所有子类，从而可能导致子类需要做出对应的修改。\n尝试使用接口如果我们定义Flyable和Quackable，让子类选择实现这两个接口。\n\n从上图就能看出，每有个新子类，就需要考虑是否要实现Flyable和Quackable接口，并且可能它们之中很多实现是相同的。\n另一种方案考虑将鸭子“飞行”和“叫”这两个行为是可变化的部分，将它们取出来单独做封装，然后再组合起来。鸭子类(Duck)中只包含所有鸭子的共同特性。\n\n现在将鸭子的“飞行”和“叫”两个动作“委托”给别人处理，而不是自己实现。\n\nflyBehavior和quackBehavior可以根据具体的子类进行赋值。最后我们将得到以下类图：\n\n像实现了FlyBehaivor接口的一些列类，我们称之为“算法族”。\n策略模式的定义策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。\n","categories":["读书笔记"],"tags":["设计模式"]},{"title":"二叉堆及堆排序","url":"/2019/08/07/heap-and-heap-sort/","content":"二叉堆概述二叉堆（下文简称为堆）是一种优先队列，对于一个优先队列应该至少包含insert(插入)和deleteMin(删除最小者)两个操作。堆具有 结构性 和 堆序性 两个性质。\n\n堆的性质结构性堆是一颗 完全二叉树。所以对于一个高为$h$的完全二叉树有$ 2^h $到$2^{h+1}$个节点。这意味着有$N$个节点的完全二叉树的高为$\\left\\lfloor\\log N\\right\\rfloor$（$\\log N$向下取整）。观察完全二叉树的结构，可以发现，我们存储完全二叉树不需要使用链表，用数组即可，只需要将元素按从上到下，由左至右的顺序依次存入数组（为方便计算，数组从下标1开始存储元素）。这时，对于数组任意位置上$ i(i \\neq 0) $的元素，其左子节点在位置$2i$上，右子节点在左子节点之后的位置，即$2i+1$，它的父节点在位置$\\left\\lfloor i/2 \\right\\rfloor$上（此时$i \\neq 1$）。\n堆序性堆任意节点应该小于它的所有后裔节点，从而有了“对于每一个节点$X$，$X$的父节点元素应小于或等于$X$，根节点除外”，这就是堆序性（小堆，相反则是大堆）。\n堆的实现public class BinaryHeap&lt;T extends Comparable&lt;? super T&gt;&gt; &#123;\tprivate static final int DEFAULT_CAPACITY = 10;\tprivate T[] items;\tprivate int currentSize;\t\tpublic BinaryHeap() &#123;\t\tthis(DEFAULT_CAPACITY);\t&#125;\t\tpublic BinaryHeap(int capacity) &#123;\t\tif (capacity &lt; 0) \t\t\tcapacity = DEFAULT_CAPACITY;\t\titems = createArray(capacity);\t&#125;\t\tpublic BinaryHeap(T[] items) &#123;\t\tthis(items == null ? DEFAULT_CAPACITY : items.length);\t\tif (items != null) &#123;\t\t\tcurrentSize = items.length;\t\t\tSystem.arraycopy(items, 0, this.items, 1, currentSize);\t\t\tbuildHeap();\t\t&#125;\t&#125;\t\tpublic boolean isEmpty() &#123;\t\treturn currentSize == 0;\t&#125;\t\tpublic void clear() &#123;\t\tcurrentSize = 0;\t\titems = createArray(DEFAULT_CAPACITY);\t&#125;\t\tpublic T findMin() &#123;\t\tif (currentSize &lt; 1) \t\t\tthrow new NoSuchElementException();\t\treturn items[1];\t&#125;\t\tpublic void insert(T item) &#123;\t\tif (currentSize == items.length - 1) &#123;\t\t\tenlargeArray((items.length &lt;&lt; 1) + 1);\t\t&#125;\t\tint hole = ++currentSize;\t\tfor (items[0] = item; item.compareTo(items[hole &gt;&gt; 1]) &lt; 0; hole &gt;&gt;= 1) &#123;\t\t\titems[hole] = items[hole &gt;&gt; 1];\t\t&#125;\t\titems[hole] = item;\t&#125;\t\tpublic T deleteMin() &#123;\t\tif (isEmpty())\t\t\tthrow new NoSuchElementException();\t\tT min = findMin();\t\titems[1] = items[currentSize--];\t\tpercolateDown(1);\t\t\t\treturn min;\t&#125;\t\tprivate void percolateDown(int hole) &#123;\t\tint child;\t\tT tmp = items[hole];\t\tfor (; hole &lt;&lt; 1 &lt;= currentSize; hole = child) &#123;\t\t\tchild = hole &lt;&lt; 1;\t\t\tif (child != currentSize &amp;&amp; items[child + 1].compareTo(items[child]) &lt; 0) &#123;\t\t\t\tchild++;\t\t\t&#125;\t\t\tif (items[child].compareTo(items[hole]) &lt; 0) &#123;\t\t\t\titems[hole] = items[child];\t\t\t&#125; else &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\titems[hole] = tmp;\t&#125;\t\tprivate void buildHeap() &#123;\t\tfor (int i = currentSize &gt;&gt; 1; i &gt; 0; i--) &#123;\t\t\tpercolateDown(i);\t\t&#125;\t&#125;\t\t@Override\tpublic String toString() &#123;\t\treturn &quot;BinaryHeap [items=&quot; + Arrays.toString(items) + &quot;, currentSize=&quot; + currentSize + &quot;]&quot;;\t&#125;\t@SuppressWarnings(&quot;unchecked&quot;)\tprivate void enlargeArray(int newSize) &#123;\t\tT[] tmp = (T[]) new Comparable[newSize];\t\tSystem.arraycopy(items, 1, tmp, 1, currentSize);\t\titems = tmp;\t&#125;\t\t@SuppressWarnings(&quot;unchecked&quot;)\tprivate T[] createArray(int capacity) &#123;\t\treturn (T[]) new Comparable[capacity + 1];\t&#125;\t\tpublic static void main(String[] args) &#123;\t\tBinaryHeap&lt;Integer&gt; heap = new BinaryHeap&lt;&gt;(new Integer[] &#123;2, 5, 7, 9, 1&#125;);\t\tfor (int i = 10; i &gt; 0; i--)\t\t\theap.insert(i);\t\tSystem.out.println(&quot;Min:&quot; + heap.findMin());\t\tSystem.out.println(heap);\t&#125;&#125;\n堆排序堆排序是使用二叉堆进行排序的一种排序算法。\n堆排序实现这里堆是从数组下标0开始存储的，所以子节点位置的计算和之前的有略微不同。public class HeapSort &#123;        private static int leftChild(int i) &#123;        return 2 * i + 1;    &#125;        private static &lt;T extends Comparable&lt;? super T&gt;&gt; void percolateDown(T[] arr, int i, int n) &#123;        T temp = arr[i];        int child;        for (; leftChild(i) &lt; n; i = child) &#123;            child = leftChild(i);                        // child != n - 1意味着i还有右孩子            if (child != n - 1 &amp;&amp; arr[child+1].compareTo(arr[child]) &gt; 0) &#123;                child++;            &#125;                        // 小于temp，空穴中应该放入temp            if (temp.compareTo(arr[child]) &gt; 0) &#123;                break;            &#125; else &#123;                // 空穴下移一层                arr[i] = arr[child];            &#125;        &#125;        arr[i] = temp;    &#125;        private static &lt;T extends Comparable&lt;? super T&gt;&gt; void swap(T[] arr, int i, int j) &#123;        T temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    &#125;        public static &lt;T extends Comparable&lt;? super T&gt;&gt; void heapSort(T[] arr) &#123;        // build max heap        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123;            percolateDown(arr, i, arr.length);        &#125;                for (int i = arr.length - 1; i &gt; 0; i--) &#123;            swap(arr, 0, i);            percolateDown(arr, 0, i);        &#125;    &#125;        public static void main(String[] args) &#123;        Integer nums[] = &#123;2, 83, 34, 12, 78, 39, 20&#125;;        heapSort(nums);        Stream.of(nums).forEach(System.out::println);    &#125;&#125;\n堆排序的时间复杂度堆排序的时间复杂堆为$O(N\\log N)$。堆排序需要进行$N$次deleteMin操作，每次deleteMin操作的时间复杂度为$O(\\log N)$，因此总的时间复杂度为$O(N\\log N)$。\n源码算法完整源码\n\n二叉堆\n堆排序\n\n参考MarkAllenWeiss. 数据结构与算法分析:Java语言描述-第3版[M]. 机械工业出版社, 2016, 156-164,191-193\n","categories":["算法","数据结构"],"tags":["算法","数据结构","排序"]},{"title":"归并排序（Merge Sort）","url":"/2019/08/05/merge-sort/","content":"概述归并排序是一种时间复杂度为$ O (N\\log N) $的排序算法，使用的是 分治 的策略。算法的基本操作是合并两个已经排序的序列，因为两个序列是已经排序了的，所以将它们按顺序复制到第三个序列中，可以通过一次遍历完成。所以将原序列使用递归不断的分成两个子序列，直至序列中是元素个数为1，此时序列为已经排序完成的，将两个子序列合并，得到一个排序完成的序列，再继续合并，直至整个序列都是已排序的。\n\n算法实现算法实现主要包含两个过程：将序列从指定的开始到结束位置的子序列排序，合并两个有序的序列算法是用递归实现的，递归的边界为：指定的结束位置和和结束位置相同，此时子序列只有一个元素，显然子序列为已排序的。完整实现代码参见：MergeSort\n子序列排序private static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] eles, T[] temp, int begin, int end) &#123;    if (begin == end) &#123; // 开始位置与结束位置相同时，序列则已经排序完成        return;    &#125;    int middle = (begin + end) / 2;    // 将序列分为两个子序列，分别排序后再合并    mergeSort(eles, temp, begin, middle);    mergeSort(eles, temp, middle + 1, end);    // 合并两个排序完成的子序列    merge(eles, temp, begin, middle + 1, end);&#125;\n合并子序列private static &lt;T extends Comparable&lt;? super T&gt;&gt; void merge(T[] eles, T[] temp, int leftPos, int rightPos, int rightEnd) &#123;    int tempIndex = leftPos;    int leftEnd = rightPos - 1;    int lIndex = leftPos;    int rIndex = rightPos;        while (lIndex &lt;= leftEnd &amp;&amp; rIndex &lt;= rightEnd) &#123;        if (eles[lIndex].compareTo(eles[rIndex]) &lt;= 0) &#123;            temp[tempIndex++] = eles[lIndex++];        &#125; else &#123;            temp[tempIndex++] = eles[rIndex++];        &#125;    &#125;    // 处理left剩余的元素    while (lIndex &lt;= leftEnd) &#123;        temp[tempIndex++] = eles[lIndex++];    &#125;        // 处理right剩余的元素    while (rIndex &lt;= rightEnd) &#123;        temp[tempIndex++] = eles[rIndex++];    &#125;    // 将排序后的结果复制会原数组    for (int i = leftPos; i &lt;= rightEnd; i++) &#123;        eles[i] = temp[i];    &#125;&#125;\n算法入口public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(T[] eles) &#123;    mergeSort(eles, (T[])new Comparable[eles.length], 0, eles.length - 1);&#125;\n算法分析假设为题规模$N$为2的幂，这样我们可以将它分为连个相等的部分。对于$N = 1$，归并排序所用的时间为常数，我们将它记为1（这个常数是多少并不会影响到最终得到的时间复杂度，这里使用1方便于计算）。对于N归并排序的时间等于完成两个大小为 $N/2$ 的归并排序所用的时间加上合并的时间，合并所用的时间为线性的。所以有下列等式：\n\n\\begin{array}{lcl}\nT(1)        & = & 1 \\\\ \nT(N)  & = & 2T(N/2) + N \\tag{1}\n\\end{array}由于$N$为2的幂，所以将等式1中的$N$用$N/2$替换，并将等式两侧同时乘以2，则可以得到\n\n2T(N/2) = 2(2T(N/4) + N/2) = 4T(N/4) + N从而得到\n\nT(N) = 4T(N/4) + 2N再将$N/4$带入等式1，同样能得到\n\n4T(N/4) = 4(2T(N/8) + N/4) = 8T(N/8) + N所以我们有\n\nT(N) = 8T(N/8) + 3N以此类推，我们将能得到\n\nT(N) = 2^kT(N/2^k) + k \\cdot N其中 $k = \\log N$, 所以\n\nT(N) = NT(1) + N\\log N = N\\log N + N因此归并排序的时间复杂度为 $O(N\\log N)$。\n此证明中令$N$为2的幂，可以简化计算，当$N$不为2的幂时计算略有不同，但得到的时间复杂度仍未$O(N\\log N)$。\n思考\n归并排序的非递归实现\n如何不使用额外的内存空间完成排序\n\n参考MarkAllenWeiss. 数据结构与算法分析:Java语言描述-第3版[M]. 机械工业出版社, 2016, 193-198\n","categories":["算法"],"tags":["算法","排序"]},{"title":"一个Perl模块的编写方法","url":"/2019/05/13/%E4%B8%80%E4%B8%AAPerl%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95/","content":"起源最近在工作中需要一些Perl脚本，发现目前项目中脚本的公共功能的复用做得很差，并且现存的复用脚本也只是使用require &quot;/your/path/your_script.pl&quot;;简单的引用，并没编写成模块(.pm)，安装到@INC目录中。于是就有了这篇博文。在介绍模块编写方法之前，我们先来说说两种加载模块的方式。\n\n模块加载方式加载模块可以使用require和use关键字。\n两者的区别\nrequire是运行时加载，use是编译时加载。\nrequire可以指定路径，use只会从@INC中查找模块，找不到则会编译失败。\nrequire加载一定在当前命名空间，use可以不污染当前命名空间。\n\nuse其实将相当于下面的代码require ModuleName;import  ModuleName::(@EXPORT);\n模块的编写使用import函数导出变量和函数# Some/Module.pmpackage Some::Module;use strict;use warnings;# 由于上面使用了use strict;所以需要加这句，否则编译报错no strict &#x27;refs&#x27;;my $var1 = 513;sub import &#123;  *&#123;caller() . &quot;::fun1&quot;&#125; = \\&amp;fun1;  *&#123;caller() . &quot;::var1&quot;&#125; = \\$var1;&#125;sub fun1 &#123;  print &quot;I&#x27;m fun1.&quot;;&#125;# 所有模块都需要加，确保加载模块时返回true1;# test.pluse strict;use warnings;use 5.010;# 如果将模块已放到@INC目录下，则不需要下面的代码BEGIN &#123;    push(@INC, &quot;/your/module/path&quot;);&#125;use Some::Module;say $var1;&amp;fun1();\n运行test.pl将会有以下输出513I&#x27;m fun1.\nimport的导出方式，具体讲解参见Advanced Perl Programming(2nd Edition by Simon Cozens) — Chapter 1. Advanced Techniques\n使用Exporter模块导出变量和函数# Some/Module.pmpackage Some::Module;use strict;use warnings;use Exporter;our @ISA = qw(Exporter);our @EXPORT = qw($var1 func1);my $var1 = 513;sub fun1 &#123;  print &quot;I&#x27;m fun1.&quot;;&#125;# 所有模块都需要加，确保加载模块时返回true1;\nExporter的导出方式，这里只是使用了最简答的@EXPORT数组，还有其他的使用方法参见Exporter文档。\n面向对象的模块编写# Some/Module.pmpackage Some::Module;use strict;use warnings;sub new &#123;  my ($class, @args) = @_;  my $self = &#123;    @args,    name =&gt; &quot;Tom&quot;,    age =&gt; 18  &#125;  bless $self, $class;&#125;sub getName &#123;  my $self = shift;  return $selft-&gt;&#123;name&#125;;&#125;sub setName &#123;  my ($self, $name) = @_;  $self-&gt;&#123;name&#125; = $name;&#125;sub getExt &#123;  my ($self, $ext) = @_;  return $self-&gt;&#123;$ext&#125;;&#125;# test.pluse strict;use warnings;use 5.010;# 如果将模块已放到@INC目录下，则不需要下面的代码BEGIN &#123;    push(@INC, &quot;/your/module/path&quot;);&#125;use Some::Module;my $obj = Some::Module-&gt;new(phone =&gt; &quot;3478-1321&quot;);say &quot;Old name: &quot; . $obj-&gt;getName();$obj-&gt;setName(&quot;Jerry&quot;);say &quot;New Name: &quot; . $obj-&gt;getName();say &quot;Phone: &quot; . $obj-&gt;getExt(&quot;phone&quot;);\n运行结果Old name: TomNew Name: JerryPhone: 3478-1321\n如果想学习其他更高级的Perl面向对象编程，可以去了解一下 Mo、Moo 和 Moose等模块。\n完结🎉以上就是模块编写的一些简单总结。\n","categories":["Perl"],"tags":["Perl"]}]